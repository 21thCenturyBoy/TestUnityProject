using System;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;
using System.IO;
using System.Security.Cryptography;
using System.Text;
using Unity.VisualScripting;

namespace ScratchFramework
{
    public static class ScratchUtils_Editor
    {
        [MenuItem("Assets/Scratch/Convert TemplateDatas", false, 80)]
        public static void Editor_Convert_Datas()
        {
            if (Selection.gameObjects == null) return;

            var dataDicts = ScratchUtils.ConvertSimpleBlock(Selection.gameObjects);
            foreach (var dataDict in dataDicts)
            {
                string path = Path.Combine(ScratchConfig.Instance.TemplateDatasPath, dataDict.Key);
                File.WriteAllBytes($"{path}.bytes", dataDict.Value);
            }

            AssetDatabase.Refresh();

            RefreshGenerateCode();
        }

        [MenuItem("Assets/Scratch/RefreshGenerateCode", false, 80)]
        public static void RefreshGenerateCode()
        {
            var datas = AssetDatabase.FindAssets("t:TextAsset", new[] { ScratchConfig.Instance.TemplateDatasPath });

            ScratchConfig.Instance.TemplateDatas.Clear();
            StringBuilder sb = new StringBuilder();
            sb.AppendLine("//------------------------------------------------------------------------------\r\n" +
                          "// <auto-generated>\r\n" +
                          "//     This code was generated by a tool.\r\n" +
                          "//     Changes to this file may cause incorrect behavior and will be lost if\r\n" +
                          "//     the code is regenerated.\r\n" +
                          "// </auto-generated>\r\n" +
                          "//------------------------------------------------------------------------------");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using UnityEngine;");

            sb.AppendLine("namespace ScratchFramework");
            sb.AppendLine("{");


            List<BlockData> blockDatas = new List<BlockData>();
            for (int i = 0; i < datas.Length; i++)
            {
                string path = AssetDatabase.GUIDToAssetPath(datas[i]);

                TextAsset textAsset = AssetDatabase.LoadAssetAtPath<TextAsset>(path);
                if (textAsset != null)
                {
                    Block block = ScratchUtils.DeserializeBlock(textAsset.bytes);
                    ScratchConfig.Instance.TemplateDatas.Add(textAsset);
                    blockDatas.Add(block.GetDataRef() as BlockData);
                    GameObject.DestroyImmediate(block.gameObject);
                }
            }


            sb.AppendLine("\tpublic static class EngineBlockCodeExtension");
            sb.AppendLine("\t{");

            AddSummary("BlockData Template Dict", ref sb);
            sb.AppendLine("\t\tpublic static Dictionary<int, int> TemplateDict = new Dictionary<int, int>()");
            sb.AppendLine("\t\t{");
            for (int i = 0; i < blockDatas.Count; i++)
            {
                sb.Append("\t\t\t{(int)ScratchBlockType.");
                sb.Append($"{blockDatas[i].ScratchType}, {i}");
                sb.Append("},\r\n");
            }

            sb.AppendLine("\t\t};");

            AddSummary("BlockData Logic", ref sb);
            sb.AppendLine("\t\tpublic static IEngineBlockBaseData CreateBlockData(this ScratchBlockType type)");
            sb.AppendLine("\t\t{");
            sb.AppendLine("\t\t\tswitch (type)");
            sb.AppendLine("\t\t\t{");
            for (int i = 0; i < blockDatas.Count; i++)
            {
                sb.AppendLine("\t\t\t\tcase ScratchBlockType." + blockDatas[i].ScratchType + ": return new BlockLogic_" + blockDatas[i].ScratchType + "();");
            }

            sb.AppendLine("\t\t\t}");
            sb.AppendLine("\t\t\t return null;");
            sb.AppendLine("\t\t}");
            sb.AppendLine("\t}");

            ScratchBlockClass(ref sb, blockDatas);

            sb.AppendLine("}");
            ExportConfigTableCS(ScratchConfig.Instance.CsSharpPath + $"/EngineBlockCode.cs", sb);

            AssetDatabase.Refresh();
        }

        public static Type GetInterfaceType(BlockData blockData)
        {
            Type engineBlockType = null;
            switch (blockData.Type)
            {
                case BlockType.none:
                    break;
                case BlockType.Trigger:
                    engineBlockType = typeof(IEngineBlockTriggerBase);
                    break;
                case BlockType.Simple:
                    engineBlockType = typeof(IEngineBlockSimpleBase);
                    break;
                case BlockType.Condition:
                    engineBlockType = typeof(IEngineBlockConditionBase);
                    break;
                case BlockType.Loop:
                    engineBlockType = typeof(IEngineBlockLoopBase);
                    break;
                case BlockType.Operation:
                    if (blockData.BlockFucType == FucType.Condition)
                    {
                        engineBlockType = typeof(IEngineBlockOperationBase);
                    }

                    if (blockData.BlockFucType == FucType.GetValue)
                    {
                        engineBlockType = typeof(IEngineBlockOperationBase);
                    }
                    else if (blockData.BlockFucType == FucType.Variable)
                    {
                        engineBlockType = typeof(IEngineBlockVariableBase);
                    }

                    break;
                case BlockType.Define:
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }

            return engineBlockType;
        }

        private static string GetInterfaceName(BlockData blockData)
        {
            Type engineBlockType = GetInterfaceType(blockData);
            if (engineBlockType == null)
            {
                return string.Empty;
            }
            else
            {
                return engineBlockType.Name;
            }
        }

        private static void GetInputValuesLen(BlockData blockData, ref List<string> inputs, ref List<KeyValuePair<ScratchValueType, string>> returns)
        {
            inputs.Clear();
            returns.Clear();

            for (int i = 0; i < blockData.SectionTreeList.Length; i++)
            {
                for (int j = 0; j < blockData.SectionTreeList[i].BlockHeadTreeList.Length; j++)
                {
                    var headData = blockData.SectionTreeList[i].BlockHeadTreeList[j];
                    DataType type = headData.DataType;
                    switch (type)
                    {
                        case DataType.Undefined:
                            break;
                        case DataType.Label:
                            break;
                        case DataType.Input:
                            BlockHeaderParam_Data_Input dataInput = headData as BlockHeaderParam_Data_Input;
                            inputs.Add(dataInput.DataProperty);
                            break;
                        case DataType.Operation:
                            BlockHeaderParam_Data_Operation headOperationData = headData as BlockHeaderParam_Data_Operation;
                            if (headOperationData.GetBlockData().SectionTreeList[0].BlockHeadTreeList[0] is BlockHeaderParam_Data_RenturnVariableLabel renturnVariableLabel)
                            {
                                returns.Add(new KeyValuePair<ScratchValueType, string>(headOperationData.ValueType, renturnVariableLabel.VariableInfo));
                            }
                            break;
                        case DataType.VariableLabel:
                            break;
                        case DataType.RenturnVariableLabel:
                            break;
                        case DataType.Icon:
                            break;
                        default:
                            throw new ArgumentOutOfRangeException();
                    }
                }
            }
        }

        private static void GetInterfaceProperty(ref StringBuilder stringBuilder, BlockData blockData)
        {
            Type engineBlockType = GetInterfaceType(blockData);

            if (engineBlockType == null) return;

            if (blockData.Type == BlockType.Condition)
            {
                stringBuilder.AppendLine(string.Format($"\t\tpublic GuidList {nameof(IEngineBlockConditionBase.Branch_OperationGuids)} {{0}}{{1}});", "{ get; set; } = GuidList.CreateEmptyGuidList(", blockData.SectionTreeList.Length - 1));
                stringBuilder.AppendLine(string.Format($"\t\tpublic GuidList {nameof(IEngineBlockConditionBase.Branch_BlockGuids)} {{0}}{{1}});", "{ get; set; } = GuidList.CreateEmptyGuidList(", blockData.SectionTreeList.Length));
            }

            var properties = engineBlockType.GetProperties();
            for (int i = 0; i < properties.Length; i++)
            {
                var targetType = properties[i].PropertyType;

                string defalutVaue = targetType.IsValueType ? Activator.CreateInstance(properties[i].PropertyType).ToString() : "null";
                if (targetType.IsEnum)
                {
                    defalutVaue = targetType.Name + "." + defalutVaue;
                }

                if (properties[i].GetAttribute<BlockGuidRefAttribute>() != null)
                {
                    defalutVaue = ScratchUtils.InvalidGuid.ToString();
                }

                if (blockData.BlockFucType == FucType.Variable && blockData.OperationValueType != ScratchValueType.Undefined && targetType == typeof(ScratchValueType))
                {
                    defalutVaue = $"ScratchValueType.{blockData.OperationValueType}";
                }

                stringBuilder.AppendLine($"\t\tprivate {properties[i].PropertyType.FullName} m_{properties[i].Name} = {defalutVaue};");
                stringBuilder.AppendLine($"\t\tpublic {properties[i].PropertyType.FullName} {properties[i].Name}");
                stringBuilder.AppendLine("\t\t{");
                stringBuilder.AppendLine($"\t\t\tget => m_{properties[i].Name};");
                if (properties[i].SetMethod != null)
                {
                    stringBuilder.AppendLine("\t\t\tset");
                    stringBuilder.AppendLine("\t\t\t{");
                    stringBuilder.AppendLine($"\t\t\t\tSet{properties[i].Name}(ref value);");
                    stringBuilder.AppendLine($"\t\t\t\tm_{properties[i].Name} = value;");
                    stringBuilder.AppendLine("\t\t\t}");
                }

                stringBuilder.AppendLine("\t\t}");
                stringBuilder.AppendLine($"\t\tpartial void Set{properties[i].Name}(ref {properties[i].PropertyType.FullName} newData);");
            }


            return;
        }

        private static void GenerateIEngineBlockBaseData(ref StringBuilder stringBuilder, BlockData blockData)
        {
            AddSummary("[Editor Data]功能类型", ref stringBuilder);
            stringBuilder.AppendLine($"\t\tpublic FucType FucType => FucType.{blockData.BlockFucType};");
            AddSummary("[Editor Data]逻辑类型", ref stringBuilder);
            stringBuilder.AppendLine($"\t\tpublic ScratchBlockType Type => ScratchBlockType.{blockData.ScratchType};");
            AddSummary("[Editor Data]UI类型", ref stringBuilder);
            stringBuilder.AppendLine($"\t\tpublic BlockType BlockType => BlockType.{blockData.Type};");
            
            AddSummary("[Editor Data]是否为画布根", ref stringBuilder);
            stringBuilder.AppendLine(string.Format($"\t\tpublic bool {nameof(IEngineBlockBaseData.IsRoot)} {{0}}", "{ get; set; } = false;"));

            AddSummary("[Editor Data]画布位置(需判断画布根时有效)", ref stringBuilder);
            stringBuilder.AppendLine(string.Format($"\t\tpublic {nameof(BVector2)} {nameof(IEngineBlockBaseData.CanvasPos)} {{0}} = {{1}}.zero;", "{ get; set; }", nameof(BVector2)));
            
            stringBuilder.AppendLine($"\t\tprivate int m_Guid = {ScratchUtils.InvalidGuid};");
            AddSummary("[Editor Data]Guid", ref stringBuilder);
            stringBuilder.AppendLine($"\t\tpublic int Guid");
            stringBuilder.AppendLine("\t\t{");
            stringBuilder.AppendLine("\t\t\tget => m_Guid;");
            stringBuilder.AppendLine("\t\t\tset");
            stringBuilder.AppendLine("\t\t\t{");
            stringBuilder.AppendLine("\t\t\t\tSetGuid(ref value);");
            stringBuilder.AppendLine("\t\t\t\tm_Guid = value;");
            stringBuilder.AppendLine("\t\t\t}");
            stringBuilder.AppendLine("\t\t}");
            stringBuilder.AppendLine("\t\tpartial void SetGuid(ref int newData);");
            
            Type type = GetInterfaceType(blockData);
            if (typeof(IBlockPlug).IsAssignableFrom(type))
            {
                stringBuilder.AppendLine($"\t\tprivate int m_NextGuid = {ScratchUtils.InvalidGuid};");
                
                AddSummary("[Editor Data]NextGuid", ref stringBuilder);
                stringBuilder.AppendLine($"\t\tpublic int NextGuid");
                stringBuilder.AppendLine("\t\t{");
                stringBuilder.AppendLine("\t\t\tget => m_NextGuid;");
                stringBuilder.AppendLine("\t\t\tset");
                stringBuilder.AppendLine("\t\t\t{");
                stringBuilder.AppendLine("\t\t\t\tSetNextGuid(ref value);");
                stringBuilder.AppendLine("\t\t\t\tm_NextGuid = value;");
                stringBuilder.AppendLine("\t\t\t}");
                stringBuilder.AppendLine("\t\t}");
                stringBuilder.AppendLine("\t\tpartial void SetNextGuid(ref int newData);");
            }
        }

        private static void GenerateIEngineBlockBaseData_InputValue(ref StringBuilder stringBuilder, BlockData blockData)
        {
            List<string> inputs = new List<string>();
            List<KeyValuePair<ScratchValueType, string>> returns = new List<KeyValuePair<ScratchValueType, string>>();

            Type type = GetInterfaceType(blockData);
            GetInputValuesLen(blockData, ref inputs, ref returns);

            if (typeof(IBlockReturnVarGuid).IsAssignableFrom(type))
            {
                for (int j = 0; j < returns.Count; j++)
                {
                    stringBuilder.AppendLine("\t\tprivate int m_ReturnVarGuid_" + j + $" = {ScratchUtils.InvalidGuid};");

                    AddSummary($"[Editor Data]{returns[j]}", ref stringBuilder);
                    stringBuilder.AppendLine("\t\tpublic int ReturnVarGuid_" + j);
                    stringBuilder.AppendLine("\t\t{");
                    stringBuilder.AppendLine("\t\t\tget => m_ReturnVarGuid_" + j + ";");
                    stringBuilder.AppendLine("\t\t\tset");
                    stringBuilder.AppendLine("\t\t\t{");
                    stringBuilder.AppendLine("\t\t\t\tSetReturnVarGuid_" + j + "(ref value);");
                    stringBuilder.AppendLine("\t\t\t\tm_ReturnVarGuid_" + j + " = value;");
                    stringBuilder.AppendLine("\t\t\t}");
                    stringBuilder.AppendLine("\t\t}");

                    AddSummary($"{returns[j]}", ref stringBuilder);
                    stringBuilder.AppendLine("\t\tpartial void SetReturnVarGuid_" + j + "(ref int newData);");
                }

                AddSummary($"获取返回值变量长度", ref stringBuilder);
                stringBuilder.AppendLine($"\t\tpublic int {nameof(IBlockReturnVarGuid.GetReturnValuesLength)}()=> {returns.Count};");
                AddSummary($"设置返回值变量Guid", ref stringBuilder);
                stringBuilder.AppendLine($"\t\tpublic void {nameof(IBlockReturnVarGuid.SetReturnValueGuid)}(int index, int value)");
                stringBuilder.AppendLine("\t\t{");
                if (returns.Count != 0)
                {
                    stringBuilder.AppendLine("\t\t\tswitch(index)");
                    stringBuilder.AppendLine("\t\t\t{");
                    for (int j = 0; j < returns.Count; j++)
                    {
                        stringBuilder.AppendLine("\t\t\t\tcase " + j + ":");
                        stringBuilder.AppendLine("\t\t\t\t\tReturnVarGuid_" + j + " = value;");
                        stringBuilder.AppendLine("\t\t\t\t\tbreak;");
                    }

                    stringBuilder.AppendLine("\t\t\t}");
                }

                stringBuilder.AppendLine("\t\t}");

                AddSummary($"获取返回值变量Guid", ref stringBuilder);
                stringBuilder.AppendLine($"\t\tpublic int {nameof(IBlockReturnVarGuid.GetReturnValueGuid)}(int index)");
                stringBuilder.AppendLine("\t\t{");
                if (returns.Count != 0)
                {
                    stringBuilder.AppendLine("\t\t\tswitch(index)");
                    stringBuilder.AppendLine("\t\t\t{");
                    for (int j = 0; j < returns.Count; j++)
                    {
                        stringBuilder.AppendLine("\t\t\t\tcase " + j + ":");
                        stringBuilder.AppendLine("\t\t\t\t\treturn ReturnVarGuid_" + j + ";");
                    }

                    stringBuilder.AppendLine("\t\t\t}");
                }


                stringBuilder.AppendLine($"\t\t\treturn {ScratchUtils.InvalidGuid};");
                stringBuilder.AppendLine("\t\t}");

                AddSummary($"获取返回值变量Guid数组", ref stringBuilder);
                stringBuilder.AppendLine($"\t\tpublic int[] {nameof(IBlockReturnVarGuid.GetReturnValues)}()");
                stringBuilder.AppendLine("\t\t{");
                stringBuilder.AppendLine("\t\t\tint[] values = new int[" + returns.Count + "];");
                for (int j = 0; j < returns.Count; j++)
                {
                    stringBuilder.AppendLine("\t\t\tvalues[" + j + "] = ReturnVarGuid_" + j + ";");
                }

                stringBuilder.AppendLine("\t\t\treturn values;");
                stringBuilder.AppendLine("\t\t}");
            }

            if (typeof(IBlockVarGuid).IsAssignableFrom(type))
            {
                for (int j = 0; j < inputs.Count; j++)
                {
                    stringBuilder.AppendLine("\t\tprivate int m_VarGuid_" + j + $" = {ScratchUtils.InvalidGuid};");

                    AddSummary($"[Editor Data]{inputs[j]}", ref stringBuilder);
                    stringBuilder.AppendLine("\t\tpublic int VarGuid_" + j);
                    stringBuilder.AppendLine("\t\t{");
                    stringBuilder.AppendLine("\t\t\tget => m_VarGuid_" + j + ";");
                    stringBuilder.AppendLine("\t\t\tset");
                    stringBuilder.AppendLine("\t\t\t{");
                    stringBuilder.AppendLine("\t\t\t\tSetVarGuid_" + j + "(ref value);");
                    stringBuilder.AppendLine("\t\t\t\tm_VarGuid_" + j + " = value;");
                    stringBuilder.AppendLine("\t\t\t}");
                    stringBuilder.AppendLine("\t\t}");

                    AddSummary(inputs[j], ref stringBuilder);
                    stringBuilder.AppendLine("\t\tpartial void SetVarGuid_" + j + "(ref int newData);");
                }

                AddSummary($"获取输入变量长度", ref stringBuilder);
                stringBuilder.AppendLine($"\t\tpublic int {nameof(IBlockVarGuid.GetVarGuidsLength)}()=> {inputs.Count};");
                AddSummary($"设置输入变量Guid", ref stringBuilder);
                stringBuilder.AppendLine($"\t\tpublic void {nameof(IBlockVarGuid.SetVarsGuid)}(int index, int value)");
                stringBuilder.AppendLine("\t\t{");

                if (inputs.Count != 0)
                {
                    stringBuilder.AppendLine("\t\t\tswitch(index)");
                    stringBuilder.AppendLine("\t\t\t{");
                    for (int j = 0; j < inputs.Count; j++)
                    {
                        stringBuilder.AppendLine("\t\t\t\tcase " + j + ":");
                        stringBuilder.AppendLine("\t\t\t\t\tVarGuid_" + j + " = value;");
                        stringBuilder.AppendLine("\t\t\t\t\tbreak;");
                    }

                    stringBuilder.AppendLine("\t\t\t}");
                }

                stringBuilder.AppendLine("\t\t}");

                AddSummary($"获取返回值变量Guid", ref stringBuilder);
                stringBuilder.AppendLine($"\t\tpublic int {nameof(IBlockVarGuid.GetVarGuid)}(int index)");
                stringBuilder.AppendLine("\t\t{");

                if (inputs.Count != 0)
                {
                    stringBuilder.AppendLine("\t\t\tswitch(index)");
                    stringBuilder.AppendLine("\t\t\t{");
                    for (int j = 0; j < inputs.Count; j++)
                    {
                        stringBuilder.AppendLine("\t\t\t\tcase " + j + ":");
                        stringBuilder.AppendLine("\t\t\t\t\treturn VarGuid_" + j + ";");
                    }

                    stringBuilder.AppendLine("\t\t\t}");
                }

                stringBuilder.AppendLine($"\t\t\treturn {ScratchUtils.InvalidGuid};");
                stringBuilder.AppendLine("\t\t}");

                AddSummary($"获取变量Guid数组", ref stringBuilder);
                stringBuilder.AppendLine($"\t\tpublic int[] {nameof(IBlockVarGuid.GetVarGuids)}()");
                stringBuilder.AppendLine("\t\t{");
                stringBuilder.AppendLine("\t\t\tint[] values = new int[" + inputs.Count + "];");
                for (int j = 0; j < inputs.Count; j++)
                {
                    stringBuilder.AppendLine("\t\t\tvalues[" + j + "] = VarGuid_" + j + ";");
                }

                stringBuilder.AppendLine("\t\t\treturn values;");
                stringBuilder.AppendLine("\t\t}");
            }
        }

        private static void AddSummary(string summary, ref StringBuilder stringBuilder)
        {
            stringBuilder.AppendLine($"\t\t/// <summary> {summary} </summary>");
        }

        public static void ScratchBlockClass(ref StringBuilder stringBuilder, List<BlockData> blockDatas)
        {
            for (int i = 0; i < blockDatas.Count; i++)
            {
                string interfaceInfos = string.IsNullOrEmpty(GetInterfaceName(blockDatas[i])) ? string.Empty : ": " + GetInterfaceName(blockDatas[i]);
                stringBuilder.AppendLine($"\tpublic partial class BlockLogic_{blockDatas[i].ScratchType} {interfaceInfos}");
                stringBuilder.AppendLine("\t{");

                GenerateIEngineBlockBaseData(ref stringBuilder, blockDatas[i]);
                GetInterfaceProperty(ref stringBuilder, blockDatas[i]);
                GenerateIEngineBlockBaseData_InputValue(ref stringBuilder, blockDatas[i]);

                stringBuilder.AppendLine("\t}");
            }
        }

        private static bool ExportConfigTableCS(string filePath, StringBuilder stringBuilder)
        {
            string md5ResCs = String.Empty;
            StringBuilder readBuilder = new StringBuilder();
            using (StreamReader reader = new StreamReader(filePath, Encoding.UTF8, false))
            {
                while (!reader.EndOfStream)
                {
                    readBuilder.AppendLine(reader.ReadLine());
                }
            }

            md5ResCs = GetFileContentMd5(readBuilder.ToString());

            String newMd5 = GetFileContentMd5(stringBuilder.ToString());
            // Debug.LogError(readBuilder.ToString() +":" +stringBuilder.ToString() );
            // Debug.LogError(md5ResCs +":"+newMd5 + ":"+readBuilder.ToString().Length +":" +stringBuilder.ToString().Length );
            if (!newMd5.Equals(md5ResCs))
            {
                using (StreamWriter writer = new StreamWriter(filePath, false, Encoding.UTF8))
                {
                    writer.Write(stringBuilder.ToString());
                }

                return true;
            }

            return false;
        }

        private static string GetFileContentMd5(string content)
        {
            byte[] result = Encoding.UTF8.GetBytes(content);
            MD5 md5 = MD5.Create();
            byte[] md5Res = md5.ComputeHash(result);
            StringBuilder md5ResString = new StringBuilder();
            for (int i = 0; i < md5Res.Length; i++)
            {
                md5ResString.Append(md5Res[i].ToString("x2"));
            }

            return md5ResString.ToString();
        }


        [MenuItem("Assets/Scratch/Convert Prefabs", false, 80)]
        public static void Editor_Convert_Prefabs()
        {
            string[] strs = Selection.assetGUIDs;
            if (strs == null || strs.Length == 0) return;

            for (int i = 0; i < strs.Length; i++)
            {
                string path = AssetDatabase.GUIDToAssetPath(strs[i]);

                TextAsset textAsset = AssetDatabase.LoadAssetAtPath<TextAsset>(path);
                Block block = ScratchUtils.DeserializeBlock(textAsset.bytes);

                string newPath = path.Replace(".bytes", ".prefab");
                var localPath = AssetDatabase.GenerateUniqueAssetPath(newPath);

                bool prefabSuccess;
                PrefabUtility.SaveAsPrefabAsset(block.gameObject, localPath, out prefabSuccess);

                GameObject.DestroyImmediate(block.gameObject);
            }

            AssetDatabase.SaveAssets();
            AssetDatabase.Refresh();
        }
    }
}