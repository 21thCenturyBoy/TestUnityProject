using System;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;
using System.IO;
using System.Security.Cryptography;
using System.Text;
using Unity.VisualScripting;

namespace ScratchFramework
{
    public static class ScratchUtils_Editor
    {
        [MenuItem("Assets/Scratch/Convert TemplateDatas", false, 80)]
        public static void Editor_Convert_Datas()
        {
            if (Selection.gameObjects == null) return;

            var dataDicts = ScratchUtils.ConvertSimpleBlock(Selection.gameObjects);
            foreach (var dataDict in dataDicts)
            {
                string path = Path.Combine(ScratchConfig.Instance.TemplateDatasPath, dataDict.Key);
                File.WriteAllBytes($"{path}.bytes", dataDict.Value);
            }

            AssetDatabase.Refresh();

            RefreshGenerateCode();
        }

        [MenuItem("Assets/Scratch/RefreshGenerateCode", false, 80)]
        public static void RefreshGenerateCode()
        {
            var datas = AssetDatabase.FindAssets("t:TextAsset", new[] { ScratchConfig.Instance.TemplateDatasPath });

            ScratchConfig.Instance.TemplateDatas.Clear();
            StringBuilder sb = new StringBuilder();
            sb.AppendLine("//------------------------------------------------------------------------------\r\n" +
                          "// <auto-generated>\r\n" +
                          "//     This code was generated by a tool.\r\n" +
                          "//     Changes to this file may cause incorrect behavior and will be lost if\r\n" +
                          "//     the code is regenerated.\r\n" +
                          "// </auto-generated>\r\n" +
                          "//------------------------------------------------------------------------------");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using UnityEngine;");

            sb.AppendLine("namespace ScratchFramework");
            sb.AppendLine("{");


            List<BlockData> blockDatas = new List<BlockData>();
            for (int i = 0; i < datas.Length; i++)
            {
                string path = AssetDatabase.GUIDToAssetPath(datas[i]);

                TextAsset textAsset = AssetDatabase.LoadAssetAtPath<TextAsset>(path);
                if (textAsset != null)
                {
                    Block block = ScratchUtils.DeserializeBlock(textAsset.bytes);
                    ScratchConfig.Instance.TemplateDatas.Add(textAsset);
                    blockDatas.Add(block.GetDataRef() as BlockData);
                    GameObject.DestroyImmediate(block.gameObject);
                }
            }


            sb.AppendLine("\tpublic static class EngineBlockCodeExtension");
            sb.AppendLine("\t{");

            AddSummary("BlockData Template Dict", ref sb);
            sb.AppendLine("\t\tpublic static Dictionary<int, int> TemplateDict = new Dictionary<int, int>()");
            sb.AppendLine("\t\t{");
            for (int i = 0; i < blockDatas.Count; i++)
            {
                sb.Append("\t\t\t{(int)ScratchBlockType.");
                sb.Append($"{blockDatas[i].ScratchType}, {i}");
                sb.Append("},\r\n");
            }

            sb.AppendLine("\t\t};");

            AddSummary("BlockData Logic", ref sb);
            sb.AppendLine("\t\tpublic static IEngineBlockBaseData CreateBlockData(this ScratchBlockType type)");
            sb.AppendLine("\t\t{");
            sb.AppendLine("\t\t\tswitch (type)");
            sb.AppendLine("\t\t\t{");
            for (int i = 0; i < blockDatas.Count; i++)
            {
                sb.AppendLine("\t\t\t\tcase ScratchBlockType." + blockDatas[i].ScratchType + ": return new BlockLogic_" + blockDatas[i].ScratchType + "();");
            }

            sb.AppendLine("\t\t\t}");
            sb.AppendLine("\t\t\t return null;");
            sb.AppendLine("\t\t}");
            sb.AppendLine("\t}");

            ScratchBlockClass(ref sb, blockDatas);

            sb.AppendLine("}");
            ExportConfigTableCS(ScratchConfig.Instance.CsSharpPath + $"/EngineBlockCode.cs", sb);

            AssetDatabase.Refresh();
        }

        public static Type GetInterfaceType(BlockData blockData)
        {
            Type engineBlockType = null;
            switch (blockData.Type)
            {
                case BlockType.none:
                    break;
                case BlockType.Trigger:
                    engineBlockType = typeof(IEngineBlockTriggerBase);
                    break;
                case BlockType.Simple:
                    engineBlockType = typeof(IEngineBlockSimpleBase);
                    break;
                case BlockType.Condition:
                    engineBlockType = typeof(IEngineBlockConditionBase);
                    break;
                case BlockType.Loop:
                    engineBlockType = typeof(IEngineBlockLoopBase);
                    break;
                case BlockType.Operation:
                    if (blockData.BlockFucType == FucType.Condition)
                    {
                        engineBlockType = typeof(IEngineBlockOperationBase);
                    }

                    if (blockData.BlockFucType == FucType.GetValue)
                    {
                        engineBlockType = typeof(IEngineBlockOperationBase);
                    }
                    else if (blockData.BlockFucType == FucType.Variable)
                    {
                        engineBlockType = typeof(IEngineBlockVariableBase);
                    }

                    break;
                case BlockType.Define:
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }

            return engineBlockType;
        }

        private static string GetInterfaceName(BlockData blockData)
        {
            Type engineBlockType = GetInterfaceType(blockData);
            if (engineBlockType == null)
            {
                return string.Empty;
            }
            else
            {
                return engineBlockType.Name;
            }
        }

        private static void GetInputValuesLen(BlockData blockData, ref List<string> inputs, ref List<KeyValuePair<ScratchValueType, string>> returns)
        {
            inputs.Clear();
            returns.Clear();

            for (int i = 0; i < blockData.SectionTreeList.Length; i++)
            {
                for (int j = 0; j < blockData.SectionTreeList[i].BlockHeadTreeList.Length; j++)
                {
                    var headData = blockData.SectionTreeList[i].BlockHeadTreeList[j];
                    DataType type = headData.DataType;
                    switch (type)
                    {
                        case DataType.Undefined:
                            break;
                        case DataType.Label:
                            break;
                        case DataType.Input:
                            BlockHeaderParam_Data_Input dataInput = headData as BlockHeaderParam_Data_Input;
                            inputs.Add(dataInput.DataProperty);
                            break;
                        case DataType.Operation:
                            BlockHeaderParam_Data_Operation headOperationData = headData as BlockHeaderParam_Data_Operation;
                            if (headOperationData.GetBlockData().SectionTreeList[0].BlockHeadTreeList[0] is BlockHeaderParam_Data_RenturnVariableLabel renturnVariableLabel)
                            {
                                returns.Add(new KeyValuePair<ScratchValueType, string>(headOperationData.ValueType, renturnVariableLabel.VariableInfo));
                            }

                            break;
                        case DataType.VariableLabel:
                            break;
                        case DataType.RenturnVariableLabel:
                            break;
                        case DataType.Icon:
                            break;
                        default:
                            throw new ArgumentOutOfRangeException();
                    }
                }
            }
        }

        private static void GetInterfaceProperty(ref StringBuilder stringBuilder, BlockData blockData)
        {
            Type engineBlockType = GetInterfaceType(blockData);

            if (engineBlockType == null) return;

            if (engineBlockType == typeof(IEngineBlockConditionBase))
            {
                stringBuilder.AppendLine(string.Format($"\t\tpublic {nameof(BGuidList)} {nameof(IEngineBlockConditionBase.BranchOperationBGuids)} {{0}}{{1}});", "{ get; set; } = BGuidList.CreateEmptyGuidList(", blockData.SectionTreeList.Length - 1));
                stringBuilder.AppendLine(string.Format($"\t\tpublic {nameof(BGuidList)} {nameof(IEngineBlockConditionBase.BranchBlockBGuids)} {{0}}{{1}});", "{ get; set; } = BGuidList.CreateEmptyGuidList(", blockData.SectionTreeList.Length));
            }

            var properties = engineBlockType.GetProperties();
            for (int i = 0; i < properties.Length; i++)
            {
                var targetType = properties[i].PropertyType;
                if (properties[i].GetAttribute<BlockGuidRefAttribute>() != null)
                {
                    stringBuilder.AppendLine($"\t\tprivate {nameof(BGuid)} m_{properties[i].Name} = BGuid.Empty;");

                    AddSummary("[Editor Data]NextGuid", ref stringBuilder);
                    stringBuilder.AppendLine($"\t\tpublic int {properties[i].Name}");
                    stringBuilder.AppendLine("\t\t{");
                    stringBuilder.AppendLine($"\t\t\tget => m_{properties[i].Name}.GetGuid();");
                    if (properties[i].SetMethod != null)
                    {
                        stringBuilder.AppendLine("\t\t\tset");
                        stringBuilder.AppendLine("\t\t\t{");
                        stringBuilder.AppendLine($"\t\t\t\tSet{properties[i].Name}(ref value);");
                        stringBuilder.AppendLine($"\t\t\t\tm_{properties[i].Name}.SetGuid(value,out m_{properties[i].Name});");
                        stringBuilder.AppendLine("\t\t\t}");
                    }

                    stringBuilder.AppendLine("\t\t}");
                    stringBuilder.AppendLine($"\t\tpartial void Set{properties[i].Name}(ref {properties[i].PropertyType.FullName} newData);");
                }
                else
                {
                    string defalutVaue = targetType.IsValueType ? Activator.CreateInstance(properties[i].PropertyType).ToString() : "null";
                    if (targetType.IsEnum)
                    {
                        defalutVaue = targetType.Name + "." + defalutVaue;
                    }


                    if (blockData.BlockFucType == FucType.Variable && blockData.OperationValueType != ScratchValueType.Undefined && targetType == typeof(ScratchValueType))
                    {
                        defalutVaue = $"ScratchValueType.{blockData.OperationValueType}";
                    }

                    stringBuilder.AppendLine($"\t\tprivate {properties[i].PropertyType.FullName} m_{properties[i].Name} = {defalutVaue};");
                    stringBuilder.AppendLine($"\t\tpublic {properties[i].PropertyType.FullName} {properties[i].Name}");
                    stringBuilder.AppendLine("\t\t{");
                    stringBuilder.AppendLine($"\t\t\tget => m_{properties[i].Name};");
                    if (properties[i].SetMethod != null)
                    {
                        stringBuilder.AppendLine("\t\t\tset");
                        stringBuilder.AppendLine("\t\t\t{");
                        stringBuilder.AppendLine($"\t\t\t\tSet{properties[i].Name}(ref value);");
                        stringBuilder.AppendLine($"\t\t\t\tm_{properties[i].Name} = value;");
                        stringBuilder.AppendLine("\t\t\t}");
                    }

                    stringBuilder.AppendLine("\t\t}");
                    stringBuilder.AppendLine($"\t\tpartial void Set{properties[i].Name}(ref {properties[i].PropertyType.FullName} newData);");
                }
            }

            return;
        }

        private static void GenerateIEngineBlockBaseData(ref StringBuilder stringBuilder, BlockData blockData)
        {
            AddSummary("[Editor Data]功能类型", ref stringBuilder);
            stringBuilder.AppendLine($"\t\tpublic FucType FucType => FucType.{blockData.BlockFucType};");
            AddSummary("[Editor Data]逻辑类型", ref stringBuilder);
            stringBuilder.AppendLine($"\t\tpublic ScratchBlockType Type => ScratchBlockType.{blockData.ScratchType};");
            AddSummary("[Editor Data]UI类型", ref stringBuilder);
            stringBuilder.AppendLine($"\t\tpublic BlockType BlockType => BlockType.{blockData.Type};");

            if (blockData.BlockFucType != FucType.Variable)
            {
                AddSummary("[Editor Data]是否为画布根", ref stringBuilder);
                stringBuilder.AppendLine(string.Format($"\t\tpublic bool {nameof(IEngineBlockCanvasData.IsRoot)} {{0}}", "{ get; set; } = false;"));

                AddSummary("[Editor Data]画布位置(需判断画布根时有效)", ref stringBuilder);
                stringBuilder.AppendLine(string.Format($"\t\tpublic {nameof(BVector2)} {nameof(IEngineBlockCanvasData.CanvasPos)} {{0}} = {{1}}.zero;", "{ get; set; }", nameof(BVector2)));
            }

            stringBuilder.AppendLine($"\t\tprivate bool m_Enable = true;");
            AddSummary("[Editor Data]编辑器逻辑是否Enable", ref stringBuilder);
            stringBuilder.AppendLine($"\t\tpublic bool Enable");
            stringBuilder.AppendLine("\t\t{");
            stringBuilder.AppendLine("\t\t\tget => m_Enable;");
            stringBuilder.AppendLine("\t\t\tset");
            stringBuilder.AppendLine("\t\t\t{");
            stringBuilder.AppendLine("\t\t\t\tSetEnable(ref value);");
            stringBuilder.AppendLine("\t\t\t\tm_Enable = value;");
            stringBuilder.AppendLine("\t\t\t}");
            stringBuilder.AppendLine("\t\t}");
            stringBuilder.AppendLine("\t\tpartial void SetEnable(ref bool newData);");


            stringBuilder.AppendLine($"\t\tprivate {nameof(BGuid)} m_Guid = BGuid.Empty;");
            AddSummary("[Editor Data]Guid", ref stringBuilder);
            stringBuilder.AppendLine($"\t\tpublic int Guid");
            stringBuilder.AppendLine("\t\t{");
            stringBuilder.AppendLine("\t\t\tget => m_Guid.GetGuid();");
            stringBuilder.AppendLine("\t\t\tset");
            stringBuilder.AppendLine("\t\t\t{");
            stringBuilder.AppendLine("\t\t\t\tSetGuid(ref value);");
            stringBuilder.AppendLine("\t\t\t\tm_Guid.SetGuid(value,out m_Guid);");
            stringBuilder.AppendLine("\t\t\t}");
            stringBuilder.AppendLine("\t\t}");
            stringBuilder.AppendLine("\t\tpartial void SetGuid(ref int newData);");

            Type type = GetInterfaceType(blockData);
            if (typeof(IBlockPlug).IsAssignableFrom(type))
            {
                stringBuilder.AppendLine($"\t\tprivate {nameof(BGuid)} m_NextGuid = BGuid.Empty;");

                AddSummary("[Editor Data]NextGuid", ref stringBuilder);
                stringBuilder.AppendLine($"\t\tpublic int NextGuid");
                stringBuilder.AppendLine("\t\t{");
                stringBuilder.AppendLine("\t\t\tget => m_NextGuid.GetGuid();");
                stringBuilder.AppendLine("\t\t\tset");
                stringBuilder.AppendLine("\t\t\t{");
                stringBuilder.AppendLine("\t\t\t\tSetNextGuid(ref value);");
                stringBuilder.AppendLine("\t\t\t\tm_NextGuid.SetGuid(value,out m_NextGuid);");
                stringBuilder.AppendLine("\t\t\t}");
                stringBuilder.AppendLine("\t\t}");
                stringBuilder.AppendLine("\t\tpartial void SetNextGuid(ref int newData);");
            }
        }

        private static void GenerateIEngineBlockBaseData_InputValue(ref StringBuilder stringBuilder, BlockData blockData)
        {
            List<string> inputs = new List<string>();
            List<KeyValuePair<ScratchValueType, string>> returns = new List<KeyValuePair<ScratchValueType, string>>();

            Type type = GetInterfaceType(blockData);
            GetInputValuesLen(blockData, ref inputs, ref returns);

            if (typeof(IBlockReturnVarGuid).IsAssignableFrom(type))
            {
                for (int j = 0; j < returns.Count; j++)
                {
                    stringBuilder.AppendLine("\t\tprivate BGuid m_ReturnVarGuid_" + j + $" = BGuid.Empty;");

                    AddSummary($"[Editor Data]{returns[j]}", ref stringBuilder);
                    stringBuilder.AppendLine("\t\tpublic int ReturnVarGuid_" + j);
                    stringBuilder.AppendLine("\t\t{");
                    stringBuilder.AppendLine("\t\t\tget => m_ReturnVarGuid_" + j + ".GetGuid();");
                    stringBuilder.AppendLine("\t\t\tset");
                    stringBuilder.AppendLine("\t\t\t{");
                    stringBuilder.AppendLine("\t\t\t\tSetReturnVarGuid_" + j + "(ref value);");
                    stringBuilder.AppendLine("\t\t\t\tm_ReturnVarGuid_" + j + ".SetGuid(value,out m_ReturnVarGuid_" + j + ");");
                    stringBuilder.AppendLine("\t\t\t}");
                    stringBuilder.AppendLine("\t\t}");

                    AddSummary($"{returns[j]}", ref stringBuilder);
                    stringBuilder.AppendLine("\t\tpartial void SetReturnVarGuid_" + j + "(ref int newData);");
                }

                AddSummary($"获取返回值变量长度", ref stringBuilder);
                stringBuilder.AppendLine($"\t\tpublic int {nameof(IBlockReturnVarGuid.GetReturnValuesLength)}()=> {returns.Count};");
                AddSummary($"设置返回值变量Guid", ref stringBuilder);
                stringBuilder.AppendLine($"\t\tpublic void {nameof(IBlockReturnVarGuid.SetReturnValueGuid)}(int index, int value)");
                stringBuilder.AppendLine("\t\t{");
                if (returns.Count != 0)
                {
                    stringBuilder.AppendLine("\t\t\tswitch(index)");
                    stringBuilder.AppendLine("\t\t\t{");
                    for (int j = 0; j < returns.Count; j++)
                    {
                        stringBuilder.AppendLine("\t\t\t\tcase " + j + ":");
                        stringBuilder.AppendLine("\t\t\t\t\tReturnVarGuid_" + j + " = value;");
                        stringBuilder.AppendLine("\t\t\t\t\tbreak;");
                    }

                    stringBuilder.AppendLine("\t\t\t}");
                }

                stringBuilder.AppendLine("\t\t}");

                AddSummary($"获取返回值变量Guid", ref stringBuilder);
                stringBuilder.AppendLine($"\t\tpublic int {nameof(IBlockReturnVarGuid.GetReturnValueGuid)}(int index)");
                stringBuilder.AppendLine("\t\t{");
                if (returns.Count != 0)
                {
                    stringBuilder.AppendLine("\t\t\tswitch(index)");
                    stringBuilder.AppendLine("\t\t\t{");
                    for (int j = 0; j < returns.Count; j++)
                    {
                        stringBuilder.AppendLine("\t\t\t\tcase " + j + ":");
                        stringBuilder.AppendLine("\t\t\t\t\treturn ReturnVarGuid_" + j + ";");
                    }

                    stringBuilder.AppendLine("\t\t\t}");
                }


                stringBuilder.AppendLine($"\t\t\treturn {ScratchUtils.InvalidGuid};");
                stringBuilder.AppendLine("\t\t}");

                AddSummary($"获取返回值变量Guid数组", ref stringBuilder);
                stringBuilder.AppendLine($"\t\tpublic int[] {nameof(IBlockReturnVarGuid.GetReturnValues)}()");
                stringBuilder.AppendLine("\t\t{");
                stringBuilder.AppendLine("\t\t\tint[] values = new int[" + returns.Count + "];");
                for (int j = 0; j < returns.Count; j++)
                {
                    stringBuilder.AppendLine("\t\t\tvalues[" + j + "] = ReturnVarGuid_" + j + ";");
                }

                stringBuilder.AppendLine("\t\t\treturn values;");
                stringBuilder.AppendLine("\t\t}");
            }

            if (typeof(IBlockVarGuid).IsAssignableFrom(type))
            {
                for (int j = 0; j < inputs.Count; j++)
                {
                    stringBuilder.AppendLine("\t\tprivate BGuid m_VarGuid_" + j + $" = BGuid.Empty;");

                    AddSummary($"[Editor Data]{inputs[j]}", ref stringBuilder);
                    stringBuilder.AppendLine("\t\tpublic int VarGuid_" + j);
                    stringBuilder.AppendLine("\t\t{");
                    stringBuilder.AppendLine("\t\t\tget => m_VarGuid_" + j + ".GetGuid();");
                    stringBuilder.AppendLine("\t\t\tset");
                    stringBuilder.AppendLine("\t\t\t{");
                    stringBuilder.AppendLine("\t\t\t\tSetVarGuid_" + j + "(ref value);");
                    stringBuilder.AppendLine("\t\t\t\tm_VarGuid_" + j + ".SetGuid(value,out m_VarGuid_" + j + ");");
                    stringBuilder.AppendLine("\t\t\t}");
                    stringBuilder.AppendLine("\t\t}");

                    AddSummary(inputs[j], ref stringBuilder);
                    stringBuilder.AppendLine("\t\tpartial void SetVarGuid_" + j + "(ref int newData);");
                }

                AddSummary($"获取输入变量长度", ref stringBuilder);
                stringBuilder.AppendLine($"\t\tpublic int {nameof(IBlockVarGuid.GetVarGuidsLength)}()=> {inputs.Count};");
                AddSummary($"设置输入变量Guid", ref stringBuilder);
                stringBuilder.AppendLine($"\t\tpublic void {nameof(IBlockVarGuid.SetVarsGuid)}(int index, int value)");
                stringBuilder.AppendLine("\t\t{");

                if (inputs.Count != 0)
                {
                    stringBuilder.AppendLine("\t\t\tswitch(index)");
                    stringBuilder.AppendLine("\t\t\t{");
                    for (int j = 0; j < inputs.Count; j++)
                    {
                        stringBuilder.AppendLine("\t\t\t\tcase " + j + ":");
                        stringBuilder.AppendLine("\t\t\t\t\tVarGuid_" + j + " = value;");
                        stringBuilder.AppendLine("\t\t\t\t\tbreak;");
                    }

                    stringBuilder.AppendLine("\t\t\t}");
                }

                stringBuilder.AppendLine("\t\t}");

                AddSummary($"获取返回值变量Guid", ref stringBuilder);
                stringBuilder.AppendLine($"\t\tpublic int {nameof(IBlockVarGuid.GetVarGuid)}(int index)");
                stringBuilder.AppendLine("\t\t{");

                if (inputs.Count != 0)
                {
                    stringBuilder.AppendLine("\t\t\tswitch(index)");
                    stringBuilder.AppendLine("\t\t\t{");
                    for (int j = 0; j < inputs.Count; j++)
                    {
                        stringBuilder.AppendLine("\t\t\t\tcase " + j + ":");
                        stringBuilder.AppendLine("\t\t\t\t\treturn VarGuid_" + j + ";");
                    }

                    stringBuilder.AppendLine("\t\t\t}");
                }

                stringBuilder.AppendLine($"\t\t\treturn {ScratchUtils.InvalidGuid};");
                stringBuilder.AppendLine("\t\t}");

                AddSummary($"获取变量Guid数组", ref stringBuilder);
                stringBuilder.AppendLine($"\t\tpublic int[] {nameof(IBlockVarGuid.GetVarGuids)}()");
                stringBuilder.AppendLine("\t\t{");
                stringBuilder.AppendLine("\t\t\tint[] values = new int[" + inputs.Count + "];");
                for (int j = 0; j < inputs.Count; j++)
                {
                    stringBuilder.AppendLine("\t\t\tvalues[" + j + "] = VarGuid_" + j + ";");
                }

                stringBuilder.AppendLine("\t\t\treturn values;");
                stringBuilder.AppendLine("\t\t}");
            }
        }

        private static void AddSummary(string summary, ref StringBuilder stringBuilder)
        {
            stringBuilder.AppendLine($"\t\t/// <summary> {summary} </summary>");
        }


        private static void GenerateGetGuids(ref StringBuilder stringBuilder, BlockData blockData)
        {
            Type type = GetInterfaceType(blockData);

            int num = 1;
            StringBuilder temp_1 = new StringBuilder();
            StringBuilder temp_2 = new StringBuilder();
            string temp_guidLen = string.Empty;

            temp_1.AppendLine($"\t\t\t\tm_Guids[index] = Guid;");
            temp_2.AppendLine("\t\t\tif (Guid != ScratchUtils.InvalidGuid && map.ContainsKey(Guid)) Guid = map[Guid];");

            if (typeof(IBlockPlug).IsAssignableFrom(type))
            {
                num++;
                temp_1.AppendLine("\t\t\t\tindex++;");
                temp_1.AppendLine($"\t\t\t\tm_Guids[index] = NextGuid;");

                temp_2.AppendLine("\t\t\tif (NextGuid != ScratchUtils.InvalidGuid && map.ContainsKey(NextGuid)) NextGuid = map[NextGuid];");
            }

            if (typeof(IEngineBlockVariableBase).IsAssignableFrom(type))
            {
                num++;
                temp_1.AppendLine("\t\t\t\tindex++;");
                temp_1.AppendLine($"\t\t\t\tm_Guids[index] = {nameof(IEngineBlockVariableBase.ReturnParentGuid)};");

                temp_2.AppendLine($"\t\t\tif ({nameof(IEngineBlockVariableBase.ReturnParentGuid)} != ScratchUtils.InvalidGuid && map.ContainsKey({nameof(IEngineBlockVariableBase.ReturnParentGuid)})) {nameof(IEngineBlockVariableBase.ReturnParentGuid)} = map[{nameof(IEngineBlockVariableBase.ReturnParentGuid)}];");
            }
            
            List<string> inputs = new List<string>();
            List<KeyValuePair<ScratchValueType, string>> returns = new List<KeyValuePair<ScratchValueType, string>>();

            GetInputValuesLen(blockData, ref inputs, ref returns);
            if (typeof(IBlockVarGuid).IsAssignableFrom(type))
            {
                for (int i = 0; i < inputs.Count; i++)
                {
                    num++;
                    temp_1.AppendLine("\t\t\t\tindex++;");
                    temp_1.AppendLine($"\t\t\t\tm_Guids[index] = VarGuid_{i};");

                    temp_2.AppendLine($"\t\t\tif (VarGuid_{i} != ScratchUtils.InvalidGuid && map.ContainsKey(VarGuid_{i})) VarGuid_{i} = map[VarGuid_{i}];");
                }
            }

            if (typeof(IBlockReturnVarGuid).IsAssignableFrom(type))
            {
                for (int i = 0; i < returns.Count; i++)
                {
                    num++;
                    temp_1.AppendLine("\t\t\t\tindex++;");
                    temp_1.AppendLine($"\t\t\t\tm_Guids[index] = ReturnVarGuid_{i};");

                    temp_2.AppendLine($"\t\t\tif (ReturnVarGuid_{i} != ScratchUtils.InvalidGuid && map.ContainsKey(ReturnVarGuid_{i})) ReturnVarGuid_{i} = map[ReturnVarGuid_{i}];");
                }
            }

            if (typeof(IEngineBlockConditionBase).IsAssignableFrom(type))
            {
                temp_1.AppendLine("\t\t\t\tindex++;");
                temp_1.AppendLine("\t\t\t\tfor (int i = 0; i < BranchOperationBGuids.Length; i++)");
                temp_1.AppendLine("\t\t\t\t{");
                temp_1.AppendLine("\t\t\t\t\tm_Guids[i + index] = BranchOperationBGuids[i];");
                temp_1.AppendLine("\t\t\t\t}");
                temp_1.AppendLine("\t\t\t\tindex += BranchOperationBGuids.Length;");
                temp_1.AppendLine("\t\t\t\tfor (int i = 0; i < BranchBlockBGuids.Length; i++)");
                temp_1.AppendLine("\t\t\t\t{");
                temp_1.AppendLine("\t\t\t\t\tm_Guids[i + index] = BranchBlockBGuids[i];");
                temp_1.AppendLine("\t\t\t\t}");

                temp_2.AppendLine("\t\t\tfor (int i = 0; i < BranchOperationBGuids.Length; i++)");
                temp_2.AppendLine("\t\t\t{");
                temp_2.AppendLine("\t\t\t\tif (BranchOperationBGuids[i] != ScratchUtils.InvalidGuid && map.ContainsKey(BranchOperationBGuids[i])) BranchOperationBGuids[i] = map[BranchOperationBGuids[i]];");
                temp_2.AppendLine("\t\t\t}");

                temp_2.AppendLine("\t\t\tfor (int i = 0; i < BranchBlockBGuids.Length; i++)");
                temp_2.AppendLine("\t\t\t{");
                temp_2.AppendLine("\t\t\t\tif (BranchBlockBGuids[i] != ScratchUtils.InvalidGuid && map.ContainsKey(BranchBlockBGuids[i])) BranchBlockBGuids[i] = map[BranchBlockBGuids[i]];");
                temp_2.AppendLine("\t\t\t}");


                temp_guidLen = ($"\t\t\t\tint guidLen = {num} + BranchOperationBGuids.Length + BranchBlockBGuids.Length;");
            }
            else
            {
                temp_guidLen = ($"\t\t\t\tint guidLen = {num};");
            }


            stringBuilder.AppendLine("\t\tprivate int[] m_Guids = null;");
            stringBuilder.AppendLine($"\t\tpublic int[] {nameof(IEngineBlockBaseData.GetGuids)}()");
            stringBuilder.AppendLine("\t\t{");
            stringBuilder.AppendLine("\t\t\tif (m_Guids == null)");
            stringBuilder.AppendLine("\t\t\t{");

            stringBuilder.AppendLine(temp_guidLen);

            stringBuilder.AppendLine("\t\t\t\tm_Guids = new int[guidLen];");

            stringBuilder.AppendLine("\t\t\t\tint index = 0;");

            stringBuilder.AppendLine(temp_1.ToString());

            stringBuilder.AppendLine("\t\t\t}");
            stringBuilder.AppendLine("\t\t\telse");
            stringBuilder.AppendLine("\t\t\t{");

            stringBuilder.AppendLine(temp_guidLen);
            stringBuilder.AppendLine("\t\t\t\tif (guidLen != m_Guids.Length)");
            stringBuilder.AppendLine("\t\t\t\t{");
            stringBuilder.AppendLine("\t\t\t\t\tm_Guids = new int[guidLen];");
            stringBuilder.AppendLine("\t\t\t\t}");

            stringBuilder.AppendLine("\t\t\t\tint index = 0;");
            stringBuilder.AppendLine(temp_1.ToString());

            stringBuilder.AppendLine("\t\t\t}");

            stringBuilder.AppendLine("\t\t\treturn m_Guids;");
            stringBuilder.AppendLine("\t\t}");

            stringBuilder.AppendLine("\t\tpublic void RefreshGuids(Dictionary<int, int> map)");
            stringBuilder.AppendLine("\t\t{");

            stringBuilder.AppendLine(temp_2.ToString());

            stringBuilder.AppendLine("\t\t}");
        }

        public static void ScratchBlockClass(ref StringBuilder stringBuilder, List<BlockData> blockDatas)
        {
            for (int i = 0; i < blockDatas.Count; i++)
            {
                string interfaceInfos = string.IsNullOrEmpty(GetInterfaceName(blockDatas[i])) ? string.Empty : ": " + GetInterfaceName(blockDatas[i]);
                stringBuilder.AppendLine($"\tpublic partial class BlockLogic_{blockDatas[i].ScratchType} {interfaceInfos}");
                stringBuilder.AppendLine("\t{");

                GenerateIEngineBlockBaseData(ref stringBuilder, blockDatas[i]);
                GetInterfaceProperty(ref stringBuilder, blockDatas[i]);
                GenerateIEngineBlockBaseData_InputValue(ref stringBuilder, blockDatas[i]);
                GenerateGetGuids(ref stringBuilder, blockDatas[i]);

                stringBuilder.AppendLine("\t}");
            }
        }

        private static bool ExportConfigTableCS(string filePath, StringBuilder stringBuilder)
        {
            string md5ResCs = String.Empty;
            StringBuilder readBuilder = new StringBuilder();
            using (StreamReader reader = new StreamReader(filePath, Encoding.UTF8, false))
            {
                while (!reader.EndOfStream)
                {
                    readBuilder.AppendLine(reader.ReadLine());
                }
            }

            md5ResCs = GetFileContentMd5(readBuilder.ToString());

            String newMd5 = GetFileContentMd5(stringBuilder.ToString());
            // Debug.LogError(readBuilder.ToString() +":" +stringBuilder.ToString() );
            // Debug.LogError(md5ResCs +":"+newMd5 + ":"+readBuilder.ToString().Length +":" +stringBuilder.ToString().Length );
            if (!newMd5.Equals(md5ResCs))
            {
                using (StreamWriter writer = new StreamWriter(filePath, false, Encoding.UTF8))
                {
                    writer.Write(stringBuilder.ToString());
                }

                return true;
            }

            return false;
        }

        private static string GetFileContentMd5(string content)
        {
            byte[] result = Encoding.UTF8.GetBytes(content);
            MD5 md5 = MD5.Create();
            byte[] md5Res = md5.ComputeHash(result);
            StringBuilder md5ResString = new StringBuilder();
            for (int i = 0; i < md5Res.Length; i++)
            {
                md5ResString.Append(md5Res[i].ToString("x2"));
            }

            return md5ResString.ToString();
        }


        [MenuItem("Assets/Scratch/Convert Prefabs", false, 80)]
        public static void Editor_Convert_Prefabs()
        {
            string[] strs = Selection.assetGUIDs;
            if (strs == null || strs.Length == 0) return;

            for (int i = 0; i < strs.Length; i++)
            {
                string path = AssetDatabase.GUIDToAssetPath(strs[i]);

                TextAsset textAsset = AssetDatabase.LoadAssetAtPath<TextAsset>(path);
                Block block = ScratchUtils.DeserializeBlock(textAsset.bytes);

                string newPath = path.Replace(".bytes", ".prefab");
                var localPath = AssetDatabase.GenerateUniqueAssetPath(newPath);

                bool prefabSuccess;
                PrefabUtility.SaveAsPrefabAsset(block.gameObject, localPath, out prefabSuccess);

                GameObject.DestroyImmediate(block.gameObject);
            }

            AssetDatabase.SaveAssets();
            AssetDatabase.Refresh();
        }
    }
}